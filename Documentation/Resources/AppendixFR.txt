
<H1 class="chapter">Annexe: Les Capteurs</H1>
<P>
EV3 Basic fait un bon travail d'auto-détection de nombreux capteurs, au moins de tous les capteurs qui sont livrés avec les 
kits NXT 2.0 et EV3. Néanmoins, le programme a besoin de savoir comment interpréter au mieux les mesures des capteurs pour 
les différents types et modes. Pour que la liste reste simple, je n'inclus que les modes que je trouve utiles. Les capteurs 
EV3 sont listés en premier et les capteurs NXT sont répertoriés dans un tableau distinct plus bas.
</P>
<P>
ReadRawValue (numéro de port, indice) est une fonction qui est très utile pour obtenir une valeur unique qui n'est pas un pourcentage, 
comme un code de couleur, par exemple. La valeur de l'indice pour ReadRawValue devrait normalement être zéro, sauf si vous avez besoin 
d'obtenir la valeur1 ou valeur2 d'un capteur, comme illustré dans le tableau ci-dessous. Si vous avez besoin d'obtenir plusieurs 
valeurs du capteur (dans un tableau), alors vous devriez utiliser plutôt ReadRaw. Voir la page à propos des capteurs et le manuel. 
La fonction ReadRawValue est disponible seulement à partir de la version 1.0.6. Il est donc important de mettre à jour votre extension 
EV3 si vous avez une version antérieure.
</P>
<P>
La balise IR (télécommande) permet de choisir entre 4 canaux (mettre le curseur à sa position supérieure pour choisir le canal 1) 
et le capteur IR (récepteur distant) peut détecter les signaux de tous les canaux en provenance de plusieurs balises en même temps.
</P>
<P>
(*) Numéros pour les boutons de la télécommande (A = en haut à gauche, B = en bas à gauche, 
C = en haut à droite, D = en bas à droite, E = balise activée):
</P>
<TABLE>
<TR><TD></TD><TD></TD></TR>
<TR><TD>A</TD><TD>1</TD></TR>
<TR><TD>B</TD><TD>2</TD></TR>
<TR><TD>C</TD><TD>3</TD></TR>
<TR><TD>D</TD><TD>4</TD></TR>
<TR><TD>E</TD><TD>9</TD></TR>
<TR><TD>A & B</TD><TD>10</TD></TR>
<TR><TD>A & C</TD><TD>5</TD></TR>
<TR><TD>A & D</TD><TD>6</TD></TR>
<TR><TD>B & C</TD><TD>7</TD></TR>
<TR><TD>B & D</TD><TD>8</TD></TR>
<TR><TD>C & D</TD><TD>11</TD></TR>
</TABLE>
<P>
D'autres combinaisons renvoient la valeur 0.
</P>
<P>
(**) A noter que le capteur gyroscopique mesure les angles en degrés mais les fonctions trigonométriques de 
Small Basic utilisent les radians. Sachez que 1 radian = 57,3 ° environ.</P>
<H3 class="subchapter">Les capteurs EV3</H3>
<table>
	<tr>
		<td>Type</td>
		<td>Mode</td>
		<td>Nom</td>
		<td>Obtenir la valeur avec</td>
		<td>Livre</td>
	</tr>
	<tr>
		<td>16</td>
		<td>0</td>
		<td>TOUCH</td>
		<td>ReadPercent</td>
		<td>0=non-enfoncé, &nbsp;100= enfoncé</td>
	</tr>

	<tr>
		<td rowspan="4">29</td>
		<td>0</td>
		<td>COL-REFLECT</td>
		<td>ReadPercent</td>
		<td>0=pas de lumière réfléchie, 100=max</td>
	</tr>
	<tr>
		<td>1</td>
		<td>COL-AMBIENT</td>
		<td>ReadPercent</td>
		<td>0=pas de lumière ambiante, 100=max</td>
	</tr>
	<tr>
		<td>2</td>
		<td>COL-COLOR</td>
		<td>ReadRawValue(port,0)</td>
		<td>0=inconnu, 1=noir, 2=bleu, 3=vert,<br>4=jaune, 5=rouge, 6=blanc, 7=brun</td>
	</tr>
	<tr>
		<td>4</td>
		<td>RGB-RAW</td>
		<td>ReadRaw (3 valeurs)</td>
		<td>value0=intensité rouge, value1=<br>intensité vert, value2=intensité bleu</td>
	</tr>
	<tr>
		<td rowspan="2">30</td>
		<td>0</td>
		<td>US-DIST-CM</td>
		<td>ReadRawValue(port,0)</td>
		<td>distance en <strong>mm</strong></td>
	</tr>
	<tr>
		<td>1</td>
		<td>US-DIST-IN</td>
		<td>ReadRawValue(port,0)</td>
		<td>distance en <strong>dixièmes de pouce</strong></td>
	</tr>
	<tr>
		<td rowspan="2">32</td>
		<td>0</td>
		<td>GYRO-ANG</td>
		<td>ReadRawValue</td>
		<td>angle en degrés (**)</td>
	</tr>
	<tr>
		<td>1</td>
		<td>GYRO-RATE</td>
		<td>ReadRawValue(port,0)</td>
		<td>vitesse de changement d'angle en deg/s</td>
	</tr>
	<tr>
		<td rowspan="3">33</td>
		<td>0</td>
		<td>IR-PROX</td>
		<td>ReadPercent</td>
		<td>distance en cm (imprécise)</td>
	</tr>
	<tr>
		<td>1</td>
		<td>IR-SEEK</td>
		<td>ReadRaw (2 valeurs)</td>
		<td>value0=direction&nbsp;de la balise IR<br>value1=distance de la balise IR</td>
	</tr>
	<tr>
		<td>2</td>
		<td>IR-REMOTE</td>
		<td>ReadRaw (4 valeurs)</td>
		<td>value0=signal du canal 1 (*),<br>value1=signal du canal 2...</td>
	</tr>
</table>


<H3 class="subchapter">Les capteurs NXT</H3>
<table>
	<tr>
		<td>Type</td>
		<td>Mode</td>
		<td>Nom</td>
		<td>Obtenir la valeur avec</td>
		<td>Livre</td>
	</tr>
	<tr>
		<td>1</td>
		<td>0</td>
		<td>NXT-TOUCH</td>
		<td>ReadPercent</td>
		<td>0=non-enfoncé, &nbsp;100=enfoncé</td>
	</tr>
	<tr>
		<td rowspan="3">4</td>
		<td>0</td>
		<td>NXT-COL-REF</td>
		<td>ReadPercent</td>
		<td>0=pas de lumière réfléchie, 100=max</td>
	</tr>
	<tr>
		<td>1</td>
		<td>NXT-COL-AMB</td>
		<td>ReadPercent</td>
		<td>0=pas de lumière ambiante, 100=max</td>
	</tr>
	<tr>
		<td>2</td>
		<td>NXT-COL-COL</td>
		<td>ReadRawValue(port,0)</td>
		<td>1=noir, 2=bleu, 3=vert, <br>4=jaune, 5=rouge, 6=blanc</td>
	</tr>
	<tr>
		<td>5</td>
		<td>0</td>
		<td>NXT-US-CM</td>
		<td>ReadRawValue(port,0)</td>
		<td>distance en <strong>cm</strong>></td>
	</tr>
</table>

<H1 class="chapter">Annexe - Didacticiel I2C</H1>
<H3 class="subchapter">Pourquoi accéder directement à I2C?</H3>
<P>
Normalement, l'interfaçage avec les capteurs de la brique EV3 est effectué à l'aide des commandes Sensor.Read ... faciles à utiliser. Mais certains périphériques tiers ne sont pas compatibles avec le protocole de capteur par défaut et nécessitent une programmation supplémentaire. Les fournisseurs de tels dispositifs fournissent normalement des blocs de programmation pour l'environnement de programmation graphique original qui gère tous les détails de la communication.
</P>
<P>
Pour EV3Basic, il n'y a probablement pas de support disponible, mais normalement il existe une documentation spécifiant le protocole de communication de bas niveau. Ayant cette information, le Sensor.CommunicateI2C ou l'une des autres commandes liées à I2C peuvent être utilisées pour implémenter un tel protocole.
</P>
<H3 class="subchapter">Introduction à I2C</H3>
<P>
I2C est une installation de communication qui permet à un seul « maître » d'accéder à plusieurs « esclaves » sur un bus commun pour lire et écrire des données. Dans le cas de l'EV3, chaque port de capteur avec son (ses) dispositif(s) capteur(s) peut former un tel bus.
</P>
<P>
La communication est effectuée par le maître qui envoie un paquet d'octets de données à un esclave ou qui demande un paquet d'octets de données. Les esclaves eux-mêmes ne peuvent initier aucun transfert de données. Comme il peut y avoir plusieurs esclaves connectés au bus, le maître doit indiquer à quel esclave il veut parler. Ceci est fait en envoyant une adresse d'esclave (un nombre de 0 à 127) avant la communication. Le concepteur du système doit s'assurer que deux esclaves sur un bus n'ont pas la même adresse pour éviter les conflits.
</P>
<P>
Le protocole I2C lui-même ne fournit qu'un moyen de communication, la signification des données dépend totalement des appareils en question.
</P>
<H3 class="subchapter">CommunicateI2C</H3>
<P>
Cette commande d’EV3 Basic est le seul moyen d'accéder directement à la fonctionnalité I2C sous forme brute. Il combine l'opération d'envoi d'un nombre arbitraire d'octets et la réception d’octets. Exemple:
</P>
<pre>
W [0] = 60
W [1] = 70
W [2] = 80
R = Sensor.CommunicateI2C (1,44,3,4, W)
</pre>
<P>
Cela enverra d'abord les octets 60, 70, 80 à l'esclave avec l'adresse 44 qui est connectée au port de capteur 1. Ensuite, il cherchera 4 octets à partir du même esclave. Les octets reçus sont stockés dans le tableau R.
</P>
<H3 class="subchapter">Registres I2C</H3>
<P>
Le concept de registres ne fait essentiellement pas partie du protocole I2C, mais ce concept est si largement utilisé qu'il est maintenant un moyen standard de communiquer avec de nombreux périphériques. Sur les appareils qui utilisent des registres, tout transfert de données est effectué par le maître qui écrit dans les registres des esclaves ou qui lit les données des registres. Un registre est essentiellement un emplacement de stockage pouvant contenir un octet de données et accessible via son numéro de registre (ou «adresse» de registre - mais utiliser ce nom mènera probablement à la confusion car les esclaves ont déjà une adresse I2C). Depuis la version 1.2.5, EV3Basic supporte directement la lecture / l'écriture de / vers des registres de périphériques I2C suivant la norme de registre.
<P>
<H3 class="subchapter">Sources de confusion</H3>
<P>
Adresse de l’esclave vs. adresse de registre. <BR>
De nombreux documents de périphériques se réfèrent à l'adresse de l’esclave et au numéro de registre comme 'adresse'. Assurez-vous de bien comprendre la différence et ce que la documentation signifie réellement dans chaque cas.
</P>
<P>
L'adresse de l’esclave est pré-multipliée par 2<BR>
Le fonctionnement interne du protocole combine les 7 bits de l'adresse de l’esclave (valeurs de 0 à 127) avec un seul bit qui spécifie la direction (lecture ou écriture) pour donner 8 bits qui doivent être transmis de maître à esclave. Parfois, les développeurs d'un périphérique écrivent simplement cette valeur combinée dans le programme pour économiser quelques cycles de processeur pendant l'exécution. Lorsque cette valeur se retrouve dans la documentation, une adresse d’esclave de par exemple 80 sera écrite 160 là. Il est parfois difficile de déterminer quelle est la véritable adresse. En cas de doute, vous devez écrire un programme de test pour vérifier si une adresse esclave est valide.
</P>

<H1 class="chapter">Annexe - Opérations logiques avancées</H1>
<H3 class="subchapter">Motivation</H3>
<P>
Dans Small Basic (et dans tous les dialectes de Basic que j'ai rencontrés) l'utilisation de comparateurs et des opérateurs logiques AND et OR est limité au contexte de If et de While. Mais parfois, il est nécessaire de conserver le résultat d'une comparaison pour une utilisation future. Pour cela, vous devez écrire quelque chose comme
</P>
<pre>
If X<10 OR X>50 Then
   A = "True"
Else
   A = "False"
EndIf
</pre>
<P>
But connaissant d'autres langages de programmation, vous préfèreriez probablement écrire ceci en une seule ligne comme
</P>
<pre>
A = X<10 OR X>50
</pre>
<p>
ce qui n'est pas possible dans Small Basic.
</p>
<p>
Mais en utilisant la commande Byte.ToLogic, il y a une façon géniale de faire la même chose même en une ligne. S'il vous plaît lire sur.
</p>
<H3 class="subchapter">Comparateurs en dehors de If et de While</H3>
<P>
Lors de la lecture de la spécification pour les commandes Byte.ToLogic attentivement, vous pouvez voir qu'il retournera "True" pour les valeurs d'entrée positives et "False" pour 0 ou négatif. Considérons donc la construction suivante: 
</P>
<pre>
A = Byte.ToLogic(X-Y)
</pre>
<P>
Cela mettra en effet A à "True" quand X est plus grand que Y, tout comme une expression de comparaison supérieure à inexistante. De la même façon, la construction
</P>
<pre>
A = Byte.ToLogic (Math.Abs(X-Y))
</pre>
<P>
est équivalente à un opérateur « non égal ». En utilisant cette idée vous pouvez créer toutes les expressions de comparaison possibles de Small Basic (certaines sont assez simples à écrire, d'autres sont plus compliquées)
</P>
<pre>
  X > Y              Byte.ToLogic(X-Y)
  X < Y              Byte.ToLogic(Y-X)
  X >= Y             Byte.ToLogic(1+Math.Floor(X-Y))
  Y <= X             Byte.ToLogic(1+Math.Floor(Y-X))
  X &lt;&gt; Y             Byte.ToLogic(Math.Abs(X-Y))
  X = Y              Byte.ToLogic(1-Math.Ceiling(Math.Abs(X-Y)))
</pre>  
<H3 class="subchapter">Mettre les comparateurs ensemble</H3>
<P>
Pour permettre une combinaison logique de comparateurs (tout comme l'exemple de motivation), vous pouvez réellement utiliser les commandes Math.Max ??et Math.Min pour faire correctement ET et OU des résultats du comparateur. Considérons l'exemple suivant: 
</P>
<pre>
A = Byte.ToLogic (Math.Max ??(10-X, X-50))
</pre>
<P>
Le premier paramètre du Max sera supérieur à zéro lorsque X est inférieur à 10. Le second paramètre du Max sera supérieur à zéro lorsque X est supérieur à 50. Le résultat de la commande Max sera supérieur à zéro lorsque l'un de ses paramètres est supérieur à zéro. En transformant cette propriété "supérieure à zéro" en une valeur logique explicite de "True" ou "False" avec la commande Byte.ToLogic, ceci est maintenant totalement équivalent à la construction inexistante:
</P>
<pre>
A = X<10 OR X>50
</pre>
<P>
tout fait en une seule ligne. Voici un résumé des opérateurs logiques (y compris NOT pour faire bonne mesure):
</P>
<pre>
  A AND B                Math.Min(A,B)
  A OR B                 Math.Max(A,B)
  NOT A                  (1-Math.Ceiling(A))
</pre>

<p>
<br><br><br><br><br>
La traduction de l'anglais en français du présent document et du fichier XML 
qui contient les textes pour le système 'Intellisense' a été assurée par Nigel 
Ward, Catherine Colardelle et Frédéric Maria en juillet 2015. Merci, Frédéric!
<br><br><br>
</p>
